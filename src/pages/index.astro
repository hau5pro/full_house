---
import { type CollectionEntry, getCollection } from "astro:content";
import BaseLayout from "../layouts/base-layout.astro";
import "./index.css";
import "../styles/recipe-grid.css";
import { UNCATEGORIZED, sortCategories } from "../infrastructure/constants";
import RecipeCard from "../components/RecipeCard.astro";

const allRecipes = await getCollection("recipes");

const groupedRecipes = allRecipes.reduce(
  (acc: Record<string, CollectionEntry<"recipes">[]>, recipe) => {
    const category = recipe.id.includes("/")
      ? recipe.id.split("/")[0]
      : UNCATEGORIZED;

    if (!acc[category]) {
      acc[category] = [];
    }
    acc[category].push(recipe);
    return acc;
  },
  {},
);

const categories = sortCategories(Object.keys(groupedRecipes));
---

<BaseLayout
  title="Full House - A Recipe Book"
  description="A personal cookbook with easy-to-follow recipes organized by category."
>
  <div class="container">
    <nav class="toc">
      <ul>
        {categories.map((category) => (
          <li><a href={`#${category}`}>{category}</a></li>
        ))}
      </ul>
    </nav>
    {
      (() => {
        let cardIndex = 0;
        return categories.map((category) => (
          <section id={category} class="category-section">
            <h2 class="category-header">{category}</h2>
            <ul class="recipe-grid">
              {groupedRecipes[category].map((recipe) => (
                <li>
                  <RecipeCard recipe={recipe} priority={cardIndex++ < 4} />
                </li>
              ))}
            </ul>
          </section>
        ));
      })()
    }
  </div>
</BaseLayout>

<script>
  // Smooth scroll for nav links — delegated on persisted header, runs once
  document.querySelector(".main-nav")?.addEventListener("click", (e) => {
    const link = (e.target as Element).closest<HTMLAnchorElement>(".cat-link");
    if (!link) return;
    const href = link.getAttribute("href");
    if (!href) return;
    const hash = href.startsWith("/#") ? href.slice(1) : href;
    const target = document.querySelector(hash);
    if (target) {
      e.preventDefault();
      target.scrollIntoView({ behavior: "smooth" });
      history.pushState(null, "", hash);
    }
  });

  // Intersection observer — re-setup on each navigation for new DOM
  let sectionObserver: IntersectionObserver | null = null;

  document.addEventListener("astro:page-load", () => {
    sectionObserver?.disconnect();

    const sections =
      document.querySelectorAll<HTMLElement>(".category-section");
    if (sections.length === 0) return;

    const navLinks = document.querySelectorAll<HTMLAnchorElement>(".cat-link");
    const nav = document.querySelector<HTMLElement>(".main-nav");

    sectionObserver = new IntersectionObserver(
      (entries) => {
        for (const entry of entries) {
          if (entry.isIntersecting) {
            const id = entry.target.id;
            navLinks.forEach((link) => {
              const href = link.getAttribute("href");
              link.classList.toggle(
                "active",
                href === `#${id}` || href === `/#${id}`,
              );
            });

            const active = nav?.querySelector(".active");
            if (active && nav) {
              active.scrollIntoView({
                inline: "center",
                block: "nearest",
                behavior: "smooth",
              });
            }
          }
        }
      },
      { rootMargin: "-20% 0px -60% 0px" },
    );

    sections.forEach((section) => sectionObserver!.observe(section));
  });
</script>
